
#ifndef __SEGMAP_KEY_GENERATORS_H__
#define __SEGMAP_KEY_GENERATORS_H__

/**
 * In [1], maps are represented as a hash with keys being created from x,y, and z coordinates,
 * and values being the map cell values. As far as I remember, the keys are generated by concatenating
 * the cells' indices. However, we have to be careful, because in a 75x75x10 map with resolution of 0.01m,
 * we need to able of representing 56250000000 cells. This number is bigger than the long limit (see [2])
 *
 * [1] Robust LIDAR Localization using Multiresolution Gaussian Mixture Maps for Autonomous Driving.
 * 		https://pdfs.semanticscholar.org/7292/1fc6b181cf75790664e482963d982ec9ac48.pdf
 * [2] http://www.cplusplus.com/reference/climits/
 */

class KeyGeneratorInterface
{
public:
	virtual ~KeyGeneratorInterface() {}
	virtual unsigned long coordinates_to_key(int cx, int cy, int cz);
	virtual void key_to_coordinates(unsigned long key, int *cx, int *cy, int *cz);
};


class KeyGen2D
{
public:
	int offset;

	KeyGen2D() { offset = 32; }

	virtual ~KeyGen2D() {}

	virtual unsigned long coordinates_to_key(int cx, int cy, int cz __attribute__((unused)))
	{
		unsigned long key = 0;

		key |= (unsigned long) cx;
		key <<= offset;
		key |= (unsigned long) cy;

		return key;
	}

	virtual void key_to_coordinates(unsigned long key, int *cx, int *cy, int *cz)
	{
		*cx = *cy = *cz = 0;
		*cy = key & 0x00000000FFFFFFFF;
		key >>= offset;
		*cx = key & 0x00000000FFFFFFFF;
	}
};


class KeyGen3D
{
public:
	int offset;

	KeyGen3D()
	{
		offset = 20;
	}

	virtual ~KeyGen3D() {}

	virtual unsigned long coordinates_to_key(int cx, int cy, int cz)
	{
		unsigned long key = 0;

		key |= (unsigned long) cx;
		key <<= offset;
		key |= (unsigned long) cy;
		key <<= offset;
		key |= (unsigned long) cz;

		return key;
	}

	virtual void key_to_coordinates(unsigned long key, int *cx, int *cy, int *cz)
	{
		*cx = *cy = *cz = 0;
		*cz = key & 0x00000000000FFFFF;
		key >>= offset;
		*cy = key & 0x00000000000FFFFF;
		key >>= offset;
		*cx = key & 0x00000000000FFFFF;
	}
};


#endif
